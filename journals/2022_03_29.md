- #🌈笔记
- # 组合继承(原型链+call)
  id:: 6242663d-ff2d-4840-a193-d5e0adea6148
	- 实现核心步骤
		- 设置子类的原型对象为父类对象
			- ```js
			  Cat.prototype = new Animal()
			  ```
		- 子类盗用父类构造函数
			- ```js
			  Animal.call(this,name,age)
			  ```
- # instanceof
	- 判断类型时使用typeof只能正确判断基本数据类型，对于引用类型，除了function，其余都返回object，无法区分其他引用类型。
- # Object
	- 一条原型链的顶端对象为Object对象
	- 所有对象都拥有Object的属性和行为
- # API
	- 静态函数(static)
		- ### `Object.definedProperty(obj,prop,desc)`：添加或修改指定对象的属性
			- `obj`：目标对象(要修改的目标)
			- `prop`：目标属性名称(字符串类型)
			- `desc`：属性描述对象
				- `value`：属性值，默认为`undefined`
				- `writable`：属性是否可以被修改，默认为false
				- `configurable`：属性是否可以配置，默认为false
					- 配置：是否能够修改描述符
				- `enumerable`：属性是否可迭代，默认为false
				- `get`：获取属性值时会执行的函数，默认为`undefined`，不能与`value`与`writable`同时出现
				- `set`：设置属性值时会执行的函数，默认为`undefined`，不能与`value`与`writable`同时出现
		- ### 布尔值`Object.is (val1,val2)`：判断两个值是否是同一个值
			- 结果为true
				- 都是`undefined`
				- 都是`null`
				- 都是`true`或`false`
				- 都是相同长度内容的字符串，且都是按相同顺序排列
				- 都是数字，且满足以下条件：
					- 都是`+0`
					- 都是`-0`
					- 都是`NaN`
					- 都是非`0`和非`NaN`的其他相同值
				- 都是相同对象(同一个引用地址)
			- ==注意==：Map(key唯一)和Set的去重底层实现依赖于`Object.is`
		- ### `Object.assign(target,sourceObj1,sourceObj2)`：将所有可枚举属性的值从一个或多个源对象分配到目标对象。==返回目标对象==。
			- 浅克隆 | 浅拷贝：对象的基本数据类型的值，以及引用数据类型的引用地址克隆，两个互相影响
		- # 克隆
			- 概念：
				- 对对象进行赋值(拷贝)
				- 针对对象的复制程度不同，可以分为浅克隆和深克隆
			- 分类
				- 浅克隆
					- 目标对象的基本数据类型的数据 和 引用数据类型的引用地址进行赋值(拷贝)，引用数据类型属性不会生成新的堆空间。
				- 实现
					- 方法一：
						- `Object.assign()`
- onchange、oninput、onblur的区别 #card
	- change输完了，失焦了，==内容变化了==，才触发；blur改没改，只要失焦就会触发，
	- input 输入一个触发一次
	-
- ### 双等 、 恒等
	- 双等：比较值，不比较类型
	- 恒等：比较值，也比较类型
- # 异步编程
	- 概念
	- 异步编程
	- 任务队列和事件循环
	- 回调函数
	- 回调地狱
	- Promise
	- async 和 await
- ## 概念
	- 同步：按照代码编写顺序依次执行的过程，被称为同步执行，该代码称为同步代码
		- 优点
			- 逻辑清晰，数据加载顺序明确
		- 缺点：
			- 代码执行效率低，系统资源利用率不高
	- 异步：未按照代码编写顺序一次执行的过程，被称为异步执行，该代码被称为异步代码
		- 优点：
			- 代码执行效率相对较高，系统利用率相对较高
		- 缺点：
			- 逻辑相对不够清晰，数据加载顺序不够明确
		- 案例：
			- 延时器与间隔定时器
			- ajax的async值为true
			- jQuery动画
- # 任务队列和事件循环
	- 目的：当同步与异步代码共存时，代码的执行顺序
	- 流程：
		- 当JavaScript执行时，会进行预编译，并将要执行的代码存储到执行栈(代码容器)中
		- 依次执行执行栈中的同步代码
		- 遇到异步代码，存储到任务队列中(未执行)，继续执行后面的代码
		- 当执行栈中的代码执行完毕后，从任务队列中取出第一个异步代码并执行，执行完毕后，继续取出下一个异步代码执行，直到任务队列中无待执行代码，程序进入等待期
- # 回调函数
	- 概念
		- 一个作为参数传入另一个函数的函数，被称为`回调函数`
	-
	- 如果后一个回调需要使用前一个回调数据时，可使用回调嵌套
	- 多次回调嵌套，形成回调地狱
	- 缺点：
		- 结构复杂，代码可读性较差
		- 代码维护成本较高
- # Promise
	- 解决回调地狱问题
	- 是ES6新增的构造函数，每个Promise对象可以用于处理一个异步回调问题
	- ## 语法：
	  collapsed:: true
		- 创建Promise对象
			- `resolve`：函数对象，异步回调执行成功时，要调用该函数
		- 代码执行顺序控制(配置`then`和`catch`)
			- `then`函数：
	- ## Promise状态
		- 概念
			- 每个Promise对象内置一个属性==status==，表示异步状态
		- 状态属性取值
		  id:: 625684f4-f7c2-4aee-9414-a5ac3604573c
			- `pending`：为`Promise`对象的默认状态取值，表示异步正在进行中
			  id:: 625684f4-ebd4-4aa8-9d6e-3df334717fc6
			- `resolve`：或者`fulfilled`，表示异步成功，由`pending`值改变得到的结果
			  id:: 625684f4-a1fc-4155-b86b-59bcbc3bd2b3
			- `reject`：表示异步失败，由`pending`值改变而来
			  id:: 625684f4-2c58-4347-bef8-ea236f32e976
		- ==注意==：每个Promise状态只能改变一次，且只能由pending改为resolve和reject
		- 流程：
			- 创建Promise对象时，将给对象的状态值设置为`pending`
			- 根据执行`resolve`和`reject`函数决定状态值为`resolve`或`reject`
			- 根据状态值决定执行`then()`或`catch`
	- # Promise.all 和 Promise.race
		- `Promise.all()`
			- 在指定异步操作==所有==都完成后执行`then`或`catch`
				- 所有异步都执行了`resolve`时会执行`then`
				- 只要有一个执行了`reject`，都会执行`catch`
		- `Promise.race()`
			- 在指定异步操作时，有==任意一个完==成后执行`then`或`catch`
				- ==最先完成==的Promise操作状态决定执行`then`或`catch`
		-