- ## const
	- 常量名要求==全大写==
	- 在声明常量时，必须赋值初始值
- const与let区别
	- const声明常量必须初始化值，否则程序会报错，而let不会
	- const常量值不能被修改，而let可以
	- 值在程序运行期间不会发生变化的使用const，可能发生变化的使用let
- ### var let const 的区别 #card
	- let 和 const 为ES6新增关键字，且作用域为块级作用域，存在暂时性死区TDZ现象，不能体现声明提升现象，不能重复定义同名变量或常量，var局部变量为函数级作用域，不存在暂时性死区，同一个作用域中可以定义同名变量
	- var、let 定义变量，声明时可以不赋初始值，值可以发生变化，const定义常量，声明时必须赋初始值，且值不可以发生变化
- # 严格模式
	- ## 分类
		- 兼容模式：js默认的模式，对语法要求不严格
		- 严格模式：使用‘use strict’由兼容模式切换到严格模式，对语法要求严格
	- ## 语法
		- 在要使用严格模式的作用域前加‘use strict’
	- ## 核心特点
	  id:: 62a03c82-5a19-4de8-811c-938a128a780b
		- ==注意==：严格模式允许变量提升；let、const没有变量提升，出现TDZ现象
		- 不能使用未声明的变量
		- 不允许函数形参重名
		- 变量名称不能使用保留字
		- 非全局作用域中的this指向undefined
	- ## 作用
		- 增强代码的安全性
		- 为新版本的js做铺垫
- ## IIFE
	- immediately invoked function expression     立即执行函数表达式
	- 在定义时就被立即执行的函数，执行完毕后，函数会被回收，不能再调用执行
	- ### 语法
		- 由两个小括号()组成，第一个：定义要执行的匿名函数，第二个：表示执行函数
		- `(function(){函数内容})(实参列表)`
- ## 递归
	- 概念：函数自己调用自己
- ## 闭包
	- 概念 (closure)
		- 当函数嵌套时，将内部函数作为外部函数的返回值，则称内部函数形成了闭包；
	- 形成条件
		- 函数嵌套
		- 内部函数作为外部函数的返回值
	- 作用
		- 内部函数可以访问外部函数的变量，==保存变量存储在内存中==的同时，限制变量的可访问操作
			- 函数执行完毕后，局部活动对象AO会被销毁，内存中就只剩下全局作用域。
			- 在局部函数执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象任然会保留在内存中，直到匿名函数被销毁才会被回收。(销毁 = 设置为null)
			- 缺点：因为闭包会保留它们包含函数的作用域，所以比其他函数更占作用域，过度使用闭包会导致内存过度占用。
	- 应用场景
		- ### 函数柯里化
			- 将接受多个参数的函数，转为处理单一参数的函数，并返回处理余下参数的函数现象。
			- ```js
			  function checkReg(reg){
			    return function(str){
			      return reg.test(str)
			    }
			  }
			  let checkTel = checkReg(/^1[3-9]\d{9}$/);
			  let checkPassword = checkReg(/^[a-zA-Z0-9]{6,12}$/);
			  
			  console.log(checkTel('124981141'))
			  console.log(checkPassword('ad12345'))
			  ```
				- 登录、注册 验证输入的input值，使用柯里化，就不用反复写格式相同的，参数不同的的独立的函数。
		- ### 函数防抖、节流
			- 概念：函数防抖、节流是优化js高频执行代码的一种手段
			- js中一些事件触发时，调用频率极高，会极大浪费系统资源，降低系统性能，为了优化提高性能，可以对其调用次数进行限制。
			- 常用的触发频率较高的事件
				- 浏览器 `resize 、scroll` 事件
				- 鼠标 `mousemove 、mouseover`
				- 表单 `input`事件
				- 键盘 `keypress  、keydown`
			- keypress  和 keydown 的区别 #card #DIFF
				- 先执行keydown，再执行keypress
				- keydown不区分大小写，keypress区分大小写
				- keypress不捕获系统功能键，keydown要捕获系统功能键
			- 防抖
				- 在事件触发n秒后再执行回调函数，如果期间又触发了事件，则重新计时
				- 利用==延时器==执行任务代码，如果已经存在延时器，则取消延时器，重新创建新的延时器
					- ```js
					  window.onmousemove = function(){
					    	let timer = null;
					    	return function(){
					        if(timer!=null){
					          clearTimeout(timer);
					        }
					        timer = setTimeout(()=>{
					          //具体执行函数
					        }，750)//一般默认750ms
					      }
					  }
					  ```
			- 节流
- ### 变量提升
  background-color:: #978626
	- 填充变量对象的顺序是：==函数的形參-＞函数声明-＞变量声明==,当变量声明遇到VO中己经有同名的时候，不会影响已经存在的属性。
	- 函数形参一由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和==undefined==值组成的一种变量对象的属性也将被创建。
	- 函数声明一由名称和对应值（函数对象(function-object)〉组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则==完全替换==这个属性。
	- 变量声明—由名称和对应值（undefined〉组成一个变量对象的属性被创建；如果变量名称跟己经声明的形式参数或函数相同，则变量声明==不会干扰==已经存在的
	- 全局变量：有var，变量提升；没有var，严格模式报错，is not defined；非严格，默认全局
	- 局部变量：有var，局部变量提升；没有var，默认为全局变量
	- 无论条件是否成立都会变量提升，一般针对if代码块，if条件判断中的语句不提升，但是if代码块中的变量可以提升
	- ```js
	  var a = '林一一'
	  function fn(){
	      if(!a){
	          var a = 12
	      }
	      console.log(a)
	  }
	  fn()
	  /* 输出
	  * 12
	  */
	  不管条件是否成立都会进行变量提升 a= undefined， if(!a) ==> if(!undefined) ==> true，输出就是 12
	  ```
	-
- [[考试总结]]
	- join  默认分隔符是逗号 ，
	- reverse 会修改原数组
	- 正则表达式，限制元素个数用逗号分隔`/\d{5,10}/`
- #新思路
	- 递归：递归当前文件夹是目录还是文件，目录继续递归，文件执行操作