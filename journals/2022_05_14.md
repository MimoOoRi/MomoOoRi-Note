- 回调地狱
	- 当前页面申请数据，调用api，对于获取的后的数据需要进行处理，只能在api的success执行处理函数。原始解决方法是传回调函数callback给api，在success中执行，如果该callback又需要调用其他的api，则继续传回调。
- 解决办法
	- ES5：promise(resolve，reject)
		- 链式调用`then`
			- 返回promise
			- 需要两个回调函数`resolve`、`reject`
				- 相当于是`promise.resolve.then` 和 `promise.reject.then`的整合
			- 常用的promise.then写法中，resolve和reject是作为`回调函数`的参数，
			- 返回了一个值，那么 then 返回的 Promise 将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。
			- 没有返回任何值，那么 then 返回的 Promise 将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。
			- 抛出一个错误，那么 then 返回的 Promise 将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。
			- 返回一个已经是接受状态的 Promise，那么 then 返回的 Promise 也会成为接受状态，并且将那个 Promise 的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。
			- 返回一个已经是拒绝状态的 Promise，那么 then 返回的 Promise 也会成为拒绝状态，并且将那个 Promise 的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。
			- 返回一个未定状态（pending）的 Promise，那么 then 返回 Promise 的状态也是未定的，并且它的终态与那个 Promise 的终态相同；同时，它变为终态时调用的回调函数参数与那个 Promise 变为终态时的回调函数的参数是相同的。
		- catch：失败后的方法
		- resolve：成功函数
			- 静态方法 Promise.resolve返回一个==解析过的Promise对象==
			- promise.resolve(value)是一个方法
			- 接受参数：promise对象、thenable、即将被解析参数
			- 返回值：
				- 返回一个带着给定值解析过的Promise对象，如果参数本身就是一个Promise对象，则直接返回这个Promise对象。
				- 返回值一定是个promise对象，才能调用then
				- 参数是promise，则直接返回自身
				- 参数是其他，则包装成promise
			- resolve之后调用的then方法，自动接受一个value，即为resolve的参数
		- reject：失败函数
	- resolve、reject：是在promise改变状态后被调用的回调函数。
		- 参数：接受一个参数
		- 返回：promise对象
		- resolve：该函数有一个参数，即接受的最终结果（the fulfillment  value）。如果该参数==不是函数==，则会在内部被替换为 (x) => x，即原样返回 promise 最终结果的函数
	- promise接受一个异步函数
	- promise.then接受两个回调函数resolve和reject
	- 链式调用，new promise()返回promise对象，then方法，返回promise对象，所以链式调用后，依然返回promise对象，并且then方法接受promise对象中已解析过的参数作为自身的参数。
	- promise(resolve，reject) 中，resolve是回调函数(回调函数接受的参数)。then接受的参数(value，reason)，是依据promise的不同状态，传入回调函数的参数。
		- 即，成功(resolve)，then中的value参数 = 传入resolve 方法中的参数
		- 失败(reject)，then中reason参数 = 传入的reject方法中的参数
	- ==return的值==会作为新Promise对象下一个then的回调函数的参数值
		- return的值：
			- 对于new Promise对象，即传入`回调函数`的值
			- 对于then方法，即 `return` 的值
			- 没有return，返回undefined。即then里没有return，promise中回调没有传值