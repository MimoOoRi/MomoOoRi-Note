- #🌈笔记
	- 大纲
		- 第一周
			- JS内容补充
			- 内存空间、变量原理、let、const、ES5语法、面向对象(ES5、ES6)、异常
		- 第二周
			- 异步编程、NodeJS、npm命令、模块化编程、HTTP协议、webpack、express(nodeJS框架)
		- 第三周
			- MVC、数据库(mongoDB)
			- 功能实现：跨域、文件上传、身份认证
			- git
	- ## 内存空间
	  collapsed:: true
		- 概念
			- 浏览器运行网页时，会向系统申请一定的内存空间，用于储存网页在运行时需要使用的数据；
			- 一个性能良好的网页，内存占用不超过100M
		- 内存模型
		  collapsed:: true
			- 栈(stack)
				- 空间大小相对较小，存储数据具有FIFO的特点
				- 数据储存的过程，成为 压栈、进栈、入栈
				- 取出过程，弹栈、出栈
			- 堆(heap)
				- 空间大小相对较大
				- 一般用于存储复合数据类型的数据
			- 池
				- 用于存储常量，称为“常量池”
		- 内存生命周期
		  collapsed:: true
			- 内存分配
				- 在变量声明变量、函数、对象、数组时，系统会自动分配内存空间
			- 内存使用
				- 内存的读、写操作，对应变量的赋值、取值操作
			- 内存回收
				- 当内存不再被使用时，会由系统的垃圾回收机制自动回收处理
		- 简单数据类型的内存分配
		  collapsed:: true
			- 分配内存
				- 在栈中存放对象变量标示名称，在堆中存放地址，在堆中存放数据
				- 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在堆中的地址，而不是堆中的数据
		- 复合(引用)数据类型的内存分配
		- 值传递
		  collapsed:: true
			- js在函数调用时，是将实参传递给形参，无论是基本类型还是引用类型，传递的都是值。但基本类型传递相当于复制，引用类型传递的值则是地址，即实参和形参都指向同一个地址，但是两个不同变量。
			- 形参和实参是栈中两个不同的变量名，但是两个参数指向同一个堆中的对象。
			- 如果修改形参的指向，即重新赋值，并不会影响实参的指向
		- ### 垃圾回收机制(扩展)
		  collapsed:: true
			- JS中有一个内置程序，负责内存回收工作，当程序中存在不再使用的内存，该程序会自动执行，回收该内存，以便以后对该内存继续使用
			- #### 垃圾回收机制CG Garbage Cllection
				- 找到不再使用的内存空间(变量)，将其进行回收释放
				- 核心机制
					- #### 引用计数机制
						- 跟踪每个变量的额引用次数，当引用次数为0，表示该变量内存可以被回收、释放
						- ```js
						  var obj = {num:1}  //count++
						  var obj1 = obj;   //count++
						  obj = null;   //count--
						  obj1 = null;   //count--
						  ```
					- #### 标记清除机制
						- js垃圾回收机制会对每个无法访问的变量打上标记，表示该变量空间可以被回收，在下一次回收程序运行时，将所有打上标记的变量内存进行回收、释放
						- 无法访问的变量
							- 在函数中定义的==局部变量==，在==函数执行完毕后==，则为无法访问的变量
							- 手动给变量赋值为null，则该变量为无法访问的变量
		- #### 提高内存利用率技巧
		  id:: 6237ec33-7584-42a5-b54d-efbc61f21590
			- 不再使用的变量，手动赋值为null
			- 尽量使用局部变量，仅保留必要的全局变量
			- 推荐使用let、const定义变量
			- 尽量不频繁创建和销毁对象，减少内存资源消耗
	- ## 变量的原理
		- js根据变量定义的位置不同，将变量分为全局变量和局部变量
		- ### 分类：
		  collapsed:: true
			- 全局变量：定义在函数外部的变量，为全局变量(var)
			- 局部变量：定义在函数内部的变量，为局部变量
		- ==注意==：如果一个变量未声明定义，直接使用，该变量会==自动成为全局变量==
		- ### 作用域
			- 概念：变量的作用范围
			- 分类
				- 全局作用域
					- 全局变量拥有全局作用域，在当前整个页面都可使用(作用范围为当前整个页面，不考虑模块化编程)
				- 局部作用域
					- 局部变量拥有局部作用域，只能在当前函数内部使用(作用范围为当前函数)
					- 每个函数都有自己的作用域，各自独立
		- ### 作用域链
			- 作用域链决定了作用域嵌套时，变量的访问顺序(优先级)
			- 优先级就近作用域原则
				- 现在当前代码所在的作用域中查找目标变量，如果存在，则直接使用，否则，查找上一层作用域中是否目标变量；存在，则直接使用，否则继续查找上一层作用域，直到在全局作用域中也没有找到，则报错
		- ### 声明提升
			- 概念：在作用域中定义==函数或变量==，会发生声明提升现象
			- 声明提升：当前作用域中声明的变量或函数会被提升到作用域的顶部，可直接访问，与声明位置无关
	- ## 作用域与作用域链的底层原理(扩展)
		- 在==js代码执行前==，系统会自动创建一系列作用域对象，用于储存各个作用域可访问的变量和函数
			- 在执行代码前就已经
		- ### 作用域对象
			- GO(global object，全局对象)
				- 用于存储全局作用域中可访问的变量和函数
				- 创建过程
				  collapsed:: true
					- 创建this、document、window等属性
					- 检查全局作用域中的声明函数，每个函数以一个GO对象的属性形式存在，属性名为函数名，属性值为函数对象
			- AO(Activation Object,执行对象，VO，Variable Object，变量对象)
				- 用于存储局部作用域中可访问的变量和函数;
				- 每个作用域都拥有自己的AO对象;
				- 创建过程:
					- 创建arguments数组对象;
					- 检查当前局部作用域中的声明函数，每个函数以一个AO对象的属性形式存在，属性名为函数名，属性值为函数对象(如果函数名冲突时，会发生覆盖);
					- 检查当前局部作用域中的var变量声明，每个var变量以一个AO对象属性形式存在，属性名为变量名，属性值为undefined，当变量名对应的属性名已经在AO中存在时，会忽略当前变量，不会创建新的属性；
		- ### 作用域链
			- 作用域链由一个GO对象和一系列AO对象组成的链式结构;
			- 查找变量和函数时，以当前代码所在的作用域对象为起点，以GO为终点，单向向上查找，直到查找到目标变量为止，查不到则程序报错;
- #查漏补缺
	- JS的引用赋值与传值赋值
		- JS分为基本类型和引用类型
		- 基本类型存放在栈区，访问时按值访问，赋值是按照普通方式赋值
		- 对象和数组是通过引用来赋值，赋值后两者都指向同一个地址，一个改变，另一个也改变
- #数据结构
  collapsed:: true
	- 双端队列
		- 允许同时从前端和后端添加和移除元素的队列
		- 应用：储存一系列撤销操作
		-
- 第二阶段查漏补缺
	- ## js发展
		- ES2015 = ES6   (15年出来的第六版)
		- ie全系不支持，edge14版本支持
		- `babel`：将es6转为es5
		- js运行环境
			- 浏览器：js可以写在HTML里进行执行
			- Nodejs：一个由c语言写的专门用于运行js代码的环境
	- ## js基础语法
		- [[变量名命名规范]]
		- Number 和 parseInt 的区别 #card
			- Number
				- 除了字符串以外，可以将其他数据类型转为数字类型
				- 布尔：true：1 ， false：0
				- ==undefined==： NaN
				- ==null==：0
				- 空的字符串：0
				- 非空非数字的字符串：NaN
				- NaN可以理解为特殊的 Number类型数据，not a number
			- parseFloat
				- 只能将==字符串==转为数字。如果是非数字的字符串，转为NaN
		-