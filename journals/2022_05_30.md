- [[数据结构与算法之美]]
	- ## 链表
		- 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。
		- 栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。
		- 空间复杂度：O(1)
			- 顺序栈： 实际上就是操作数组的最后一个元素； O(1)
			- 链式栈： 实际上就是对头节点做增删；O(1)
			- ==我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。==
		- 时间复杂度： O(1)
			- 因为都是在固定位置进行操作
- #新思路
	- outerHTML 直接替换DOM，无法使用原来的变量获取
- # react
- ## 计算属性
- 类组件中，我们设计了get方法，默认看成计算属性，当get中依赖的数据发生变化，默认执行业务，返回一个新的结果
	- ```js
	  class DEMO{
	    get total(){
	      //...
	      return ...;
	    }
	  }
	  ```
- 类组件和函数组件定义计算属性==不一样==
- ## state和props
  background-color:: #978626
- ### 组件的state
- 组件的状态：指定就是组件的响应式变化的数据
- state就是状态的意思，可以用于定义react组件内部的数据
- #### 定义state数据(两种方式)
	- 通过构造器定义内部的state变量，这种方式需要在构造器里调用super
	- 在类里面声明一个state变量(最常用)
- ==注意==：继承我们必须在构造器的第一行代码调用super()
- #### 使用state数据
	- 一般是会用state都需要==解构==，包括在render函数中也要结构。减少频繁调用`this.state`性能优化。
- #### 修改state的数据
	- 官方要求修改state必须调用setState()这个函数
	- ==特点==
		- 调用setState修改数据的时候，执行的==异步操作==
			- 在修改数据的时候，我们应该是异步操作的，有可能修改的数据比较多，比较耗时，造成页面等待
		- 异步更新数据，也可以立即获取到更新后的结果
			- 传递一个回调函数，当数据更新后就可以立即执行
		- 在react ==18.0版本及以前==，我们调用setState这个函数默认异步，放在setTimeout等等环境使用，默认会变成同步的更新
		- 关于setState的==合并操作==，如果在页面上操作某一个数据，频繁的调用setState函数，底层会默认将操作合并起来
			- setState底层默认会将回调函数存放到一个队列中
			- 如果检测到有相同的操作，将之前存放的回调函数踢出队列。保存最近的那个函数
			- react更新机制是异步的，目的也是对了提高页面效率
			- 当我们操作的数据不相同时，底层也会将操作合并在一起，更新一次
- ### props组件的外部数据
- 父组件定义数据传递给子组件的时候
- 语法规则如下：
	- #+BEGIN_QUOTE
	  当你传递的动态数据，原来这个变量时什么数据类型，子组件就是什么类型，静态数据传递过去都是字符串类型
	  #+END_QUOTE
- #### props约束
- 组件封装好了后，需要接受外部数据props传递
- 你需要的数据类型跟外面传递进来的数据类型有差别，在组件内部进行props数据校验
	- 在react中我们需要下载一个验证器（目前版本无需下载）
		- ```js
		  yarn add prop-types
		  ```
	- 验证外部的传递的==数据类型==是否符合要求，不一致，抛出警告
	- ==默认值==在类上面找到defaultProps属性就可以设置
	- 验证器需要写在class类外边
		- ```js
		  import "PropTypes" from "prop-types"
		  //propTypes是属于类的静态属性，是react提供给我们的
		  //PropTypes，大写的P，是验证验
		  类名.propTypes = {  //propTypes ≠ PropTypes
		    count:PropTypes.number.isRequired
		  }
		  
		  //默认值
		  类名.defaultProps = {  //propTypes ≠ PropTypes
		    list:[]
		  }
		  ```
- ## 单向数据流
- 数据流的方向只能从一个方向到另外一个方向，不能反过来执行
- 在vue中props也是单向数据流，但是vue可以执行修改，抛出一个警告
- 在react中我们props俩面所有的数据都是只读属性，不能修改，一旦修改，页面抛出异常
- 只要设计到对porps任何数据修改都会报错
- ==修改的props里面引用类型的属性值除外，不报错，因为setState检测不到==
	- 更新数据可以使用forceUpdate来执行，强行调用当前组件的render()
- ### 自定义事件
- 组件之间通信
	- 父传子：prop来进行接受
	- 子传父：自定义事件名字，传递后子组件调用
	- 兄弟组件：事件总线，redux状态机来完成
- 父组件中定义函数，子组件通过props调用父组件函数