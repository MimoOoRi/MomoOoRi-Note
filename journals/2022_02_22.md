- [[习题整理]]
- #🌈笔记
	- ## 对象
		- 复合型数据
		- 创建对象
			- ```js
			  var obj = new Object();
			  var obj = {}  //对象字面量
			  ```
		- 添加属性
			- ```js
			  var obj = {
			    name1 : val,
			    name2 : val,
			    bame3 : val
			  };
			  name.attr = value;
			  name[attr] = value;
			  ```
			- 属性可以是任意的数据类型，比如null、undefined、函数、数组
			- 一个对象可以有任意数量的属性
			- `obj.attr = 'val'`
		- ### 对象的遍历
			- `for-in`循环来进行遍历
				- ```js
				  for(var name in obj){
				    key.name; //undefined
				    ket[name] //目标结果
				  }
				  ```
				- 如果属性名是通过==变量==来提供，可以使用`对象名[属性名]`来获取对应value
					- 因为`for-in`得到的key是一个==数字==！！相当于for循环中的`i`(已验证)
- #新思路
	- 如何根据对象的属性值进行排序？ #card #JavaScript
	  id:: 621e00ce-23e0-421a-9127-d8e13a93125b
		- sort方法只能用在数组，不能直接用在属性名上
			- `obj.attr.sort()` ❌
		- sort内部的比较函数，接受对象，能够比较对象的值，返回对象
			- `obj.sort((a,b)=>a.attr - b.attr)`  ✅
	- ```js
	  const arr = Array(20).fill(0);
	  ```
- [[数据结构与算法之美]]
	- ## 链表
	  collapsed:: true
		- 链表的经典应用：==LRU缓存淘汰算法==
		- ### 单链表
		  collapsed:: true
			- ![https://i.imgur.com/LlmIogy.png](https://i.imgur.com/LlmIogy.png){:height 136, :width 399}
				- 后继指针：记录下一个节点地址
				- 头结点： 记录链表的基地址
				- 尾结点： 指向一个`空地址NULL`
			- 增、删
				- ![https://i.imgur.com/8H8SMQa.png](https://i.imgur.com/8H8SMQa.png){:height 183, :width 339}
		- ### 循环链表
		  collapsed:: true
			- ![https://i.imgur.com/Q7ySbQT.png](https://i.imgur.com/Q7ySbQT.png){:height 130, :width 382}
			- 尾结点：指向链表的头结点
			- 经典场景： [[约瑟夫问题]]
		- ### 双向链表
		  collapsed:: true
			- 后继指针：next ，指向后面的结点
			- 前驱指针：prev，指向前面的结点
			- 相比单链表：
				- 缺点：占用更多内存空间(prev)
				- 优点：支持双向遍历，优化删除、添加操作
			- #### 双向链表在删除、插入操作上的优化：
			  collapsed:: true
				- 删除结点中“值等于某个给定值”的结点
				- 删除给定指针指向的结点
					- 对于单链表，依旧需要遍历查找前驱结点 o(n）
					- 对于双链表，可以直接获取指向结点的前驱结点 O(1)
		- ### 双向循环链表
	- ### 空间换时间
	  collapsed:: true
		- 当内存空间充足时，为了追求代码的执行速度，可以选择空间复杂度相对较高的算法或数据结构。
		- 当内存紧缺，比如在手机或单片机上，可以用时间换空间的设计思路
	- ## 缓存
	  collapsed:: true
		- 缓存是一种提高数据读取性能的技术。
		- 缓存被用满时，哪些数据应该被清理出去，哪些应该被保留？
		- 常见淘汰策略：
			- FIFO：先进先出策略 (First In, First Out)
			- LFU：最少使用策略 (Least Frequently Used)
			- LRU：最近最少使用策略 (Least Recently Used) ,使用链表
		-
	- ## 链表、数组性能比较
	  collapsed:: true
		- 数组：
			- 优点：使用连续的内存空间，可以借助 [[CPU的缓存机制]] ，预读数组中的数据，访问效率更高
			- 缺点：(不针对JavaScript，js数组并非传统意义上的数组，本身支持动态扩容)
				- 大小固定，声明后即占用整块连续内存空间
				- 声明的数组过大，系统可能没有足够的连续内存空间分配给它
				- 声明过小，不够用，只能重新申请，拷贝原数组
		- 链表：
			- 优点：天然支持==动态扩容==
			- 缺点：
				- 非连续储存，没有办法有效预读
				- 内存消耗增大
				- 对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片或是垃圾回收(java)
	- ### 内存泄漏
		- 对于C语言，如果没有手动释放结点对应的内存空间，就会产生内存泄漏
		- 对于java这样虚拟机自动管理内存的语言来说，不需要考虑这么多
	- ### 哨兵结点
		- 背景：链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理
		- 目的：减少特殊情况的判断，例如 判空，判越界...
		- 实现：哨兵结点不储存数据，一直存在。
			- ![https://i.imgur.com/Bt32Q0i.png](https://i.imgur.com/Bt32Q0i.png){:height 118, :width 413}
			-
	- 如何使用链表实现LRU缓存淘汰算法？ #card #JavaScript
	  id:: 621e00ce-bb6b-47be-beac-9b6d5145eaea
		- ### LRU： {{cloze 最近最少使用}}
		  id:: 621e00ce-6e85-4579-b97d-6c9877f36b22
		- ### 实现
			- 维护一个==有序单链表==，越靠近链表尾部的结点是越早之前访问的。如果有一个新的数据被访问，需要从链表头开始顺序遍历链表。
				- 为什么是单链表？双链表会优化时间复杂度吗？
					- {{cloze 不会。双链表增加空间复杂度，因为储存了prev指针。无论有没有prev指针，都需要对前面的数据依次做判断O(n)。双链表只会在 指针指向特定结点 时，优化时间复杂度，因为不需要遍历进行判断。}}
					  id:: 621e00ce-2e1e-47cc-9bdf-39866c2d5d27
			- 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
			- 如果此数据没有在缓存链表中，又可以分为两种情况：
				- 如果此时缓存未满，则将此结点直接插入到链表的头部
				- 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部
		- #### 时间复杂度：无论缓存有没有满，都需要遍历一遍链表(判断是否相等)，o(O(n)
		- 继续优化： 使用[[散列表]]来记录每个数据的位置，将时间复杂度降到O(1/