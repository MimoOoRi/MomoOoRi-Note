- JavaScript
	- 数据类型
	- 1. JavaScript 有哪些数据类型，它们的区别？
		- 基本数据类型：Number、Boolean、String、Null、Undefined、Symbol、bigInt
		- 引用数据类型：Array、Object、Function
		- 引用数据类型储存在堆中，基本类型储存在栈中
	- 2. 数据类型检测的方式有哪些
		- typeOf、instanceOf、constructor、toString、isArray
	- 3. 基本数据类型和引用数据类型的区别
		- 引用数据类型储存在堆中，基本类型储存在栈中
		- 基本数据类型比较时，是比较值
		- 引用数据类型进行比较，比较的是内存地址，即便值一样，也不会返回false
	- 4. 判断数组的方式有哪些
		- isArray  (ES6)
		- arr instanceof Array
		- arr.constructor==Array
		- Array.prototype.`isPrototypeOf`([])
		- Object.prototype.toString.call    `"[object Array]"`
	- 5. null 和undefined区别
		- null原型是空对象
			- typeof null  //object
			- 定义了，但是值为空，不指向任何对象
		- undefined原型是undefined对象
			- 没有定义
	- 为什么 typeof null 得到object而不是null?
		- 因为null是空对象，值为空的对象
	- null== undefined 得到true 且 null===undefined 得到false，为什么？
		- = = 仅比较值是否相等，两个值的内存空间都没有操作数，都为假值，所以相等
		- = = = 需要比较值和类型是否相等，null原型是对象，undefined原型是undefined对象
	- intanceof 操作符的实现原理及实现
		- instanceof用来判断构造函数的prototype属性是否出现在原型链上的任何位置。
		- 即`A instanceof B` ：判断B的prototype属性指向的原型对象（ `B.prototype` ）是否在对象 `A` 的原型链
		- ==如果A的原型链经过B的原型对象，那么结果就是true==
		- 实现
			- 遍历左边变量的原型链，直到找到右边变量的 prototype，
			- 如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。
	- 为什么0.1+0.2！==0.3；如何让其相等？
		- 在JavaScript中的二进制的浮点数0.1和0.2并不是十分精确，在他们相加的结果并非正好等于0.3，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为false。
		- 相等：化浮点数为整数
	- 如何获取安全的 undefined 值？
		- 用 `void 0` 来获得 `undefined`
	- typeof NaN 的结果是什么？
		- Number
		- 因为NaN = not a number  ，但是本身是个Number对象
	- isNaN 和 Number.isNaN 函数的区别？
		- isNaN：先==转换==，不能转换都是NaN(例如传入对象也会是NaN)
		- Nunber.isNaN：先判断是否为数字，是数字再判断是否是NaN(对象不是数字，不是NaN)
	- ==操作符的强制类型转换规则？
		- 字符串和数字作比较，字符串会强行转换成数字，然后再作比较
		- 其他类型和Boolean比较，其他会被强行转换成Boolean
		- NaN不等于NaN
		- null==undefined 为true，因为都是假值
		- 对象和对象比较，是比较引用地址是否相同
	- 其他值到字符串的转换规则？
		- toString()
		- Null、Undefined转换成小写
		- Boolean转换为对应‘true’  或 ‘false’
		- Number：极大值和极小值使用指数类型，正常范围内直接转换
		- Symbol：直接转换
		- 对象：显示 [object Object]
	- 其他值到数字值的转换规则？
		- toNumber()
		- NaN：Undefined、Null、
		- Boolean：转换为0，1
		- String：使用Number转换，数字直接转换，包含非数字为NaN，==空字符为0==
		- Symbol：报错
		- 对象：转为基本类型，如果非数字则为NaN
	- JS字符串转数字的方法其他值到布尔类型的值的转换规则？
		- toBoolean
		- 假值返回false：undefined、null、false、-0、+0、NaN、“”
		- 其余为真true
	- ||和&＆操作符的返回值？
		- || 前面出现假值，则返回||后的值，逻辑或，前后只要有一个满足就返回true
		- && 逻辑与，前后同时满足才能返回true
	- Object.is() 与比较操作符“= = =” “= =”的区别？
		- Object.is()浅比较，类似于===，但是其中+0等于-0，NaN不等于NaN
		- ==只需要值相等即可，= = =需要类型也相等
	- 什么是 JavaScript 中的包装类型？
		- String、Boolean、Number
		- 在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。
		- 使用new创建String对象的引用数据类型的，这就是js的包装类型。
		- ```js
		  let str = new String('')  //直接声明基本包装类型对象
		  ```
		- 引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。
	- JavaScript 中如何进行隐式类型转换？
		- if()
		- for中第二个条件判断表达式，即i<2
		- while和do...while
		- ？：三元运算符
		- 逻辑或||  、 逻辑与 &&
	- +操作符什么时候用于字符串的拼接？
		- 操作数==出现字符串==，则进行拼接；否则执行数字加法
	- 为什么会有 Biglnt的提案？
		- JS中的Number有最大范围限制，超出会出现精度丢失
	- object.assign 和扩展运算法是深拷贝还是浅拷贝，两者区别
		- object.assign()是浅拷贝，会触发setter
		- 扩展运算符，第一层深拷贝，其他都是浅拷贝，即拷贝引用地址
			- 数组或对象中的每一个值都会被拷贝到一个新的数组或对象中，即第一层为深拷贝
			- 它不复制继承的属性或类的属性
	- let、 const、 var的区别
		- 块级作用域
			- 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。
		- 变量提升
			- var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。(暂时性死区)
		- 给全局添加属性
			- var声明的变量为[全局变量]，并且会将该变量添加为全局对象的属性，但是let和const不会。
		- 重复声明
			- var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。
			- const和let不允许重复声明变量。
		- 初始值设置：
			- const必须设置初始值，基本类型设置之后不能修改，对象中的属性可以修改
			- 即const变量指向的内存地址不能改变
		- 指针指向
			- let创建的变量是可以更改指针指向（可以重新赋值）。
			- const声明的变量是不允许改变指针的指向。
	- 如果new一个箭头函数的会怎么样
		- new关键字
			- js内部会先生成一个对象
			- 再把函数中的this指向该对象
			- 执行构造函数中的语句
			- 最后返回该对象的实例
		- 会报错
		- 因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义箭头函数，否则用new调用时会报错。
	- 箭头函数与普通函数的区别
		- 普通函数的this指向调用函数的对象，箭头函数this是基于当前函数定义的位置，即外层函数所处的环境
			- 箭头函数没有自己的this，它会捕捉自己在**定义时**所处外层执行环境的this，并继承这个this值。所以箭头函数中this的指向在它被定义的时候就已经确定了，之后不再改变。
		- 箭头函数不会创建自己的this
		- 箭头函数语法更加简洁清晰
		- **call（）、apply（）、bind（）无法改变箭头函数中this的指向**
	- 箭头函数的 this 指向哪里？
		- 外层函数的this，即外层函数所在的环境
	- 扩展运算符的作用及使用场景
		- 所有能够被迭代的东西，都可以被展开运算符展开
			- 可以展开：字符串、数组、对象
			- 不可以：Number
		- 字符串可以展开成`逗号`分隔的元素集合  `'a','b','c'`
		- 使用场景：数组的合并、数组的浅克隆、转换伪数组
	- Proxy 可以实现什么功能？
		- ```js
		  let p = new Proxy(target, handler)
		  ```
		- target代表需要代理的对象，handler用来定义对象中的操作，比如自定义setter、getter
		- 相比于definedProperty，Proxy不需要一层层递归为每个属性添加代理，可以一次性实现数据拦截，