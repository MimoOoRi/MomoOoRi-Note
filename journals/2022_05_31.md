- [[面试题]]
	- ## 事件循环 EventLoop
	- ### JS这门语言的特点
	- 弱类型语言：定义变量无需显示申明类型
	- JS是单线程语言，同一时间只能执行一件事
	- JS这门语言最早设计出来的目的就是为了解决浏览器交互问题，从一开始就考虑简单、方便以及效率。
	- JS比较核心的一块内容，DOM操作，一个线程在删除节点，一个线程在修改节点。
	- 单线程缺点：代码容易造成阻塞
	- ### 同步和异步
	- js中所有的认为都可以分为同步和异步
	- ==同步任务==：立即执行的任务，默认是在线程中运行的任务
	- ==异步任务==：比如ajax、setTimeout、等等这些操作都是异步任务，发现异步任务不会阻塞我们主线程
	- ### 事件循环过程
	- 执行步骤
		- 步骤一旦执行，立即产生一个主线程，主线程会有很多的任务
		- 主线程在执行的过程中会遇到同步任务和异步任务
		- 同步任务立即执行这个任务，遇到异步任务就分析这个任务，会将这个任务放到任务队列(queue)里面
		- 主线程执行完了同步任务后，就会去任务队列里面获取异步任务，拿到主线程运行
		- 异步任务在执行过程中又有异步任务，继续执行这个过程
		- 异步任务执行完毕，主线程才结束任务
	- ### 异步任务分类
	- 异步任务分为两种类型
	- 宏任务：setTimeout、setInterval、Ajax、文件操作、script标签
	- 微任务：then方法、Object.observe、nextTick
		- 优先级：process.nextTick >new Promise().then(回调) > MutationObserver
	- 宏任务在运行过程中一般来说时间间隔不能确定，只要是宏任务我们都会放在后面执行
	- 微任务满足==先进先出==的执行规则。一般微任务执行完了，才会执行宏任务
	- ==script标签也是宏任务==，浏览器在解析HTML网页的==时候默认会执行第一个宏任务==(解析script标签)，这个宏任务会有很多的宏任务和微任务
	-
- #新思路
	- 少用全局变量，全局变量最后才释放空间
	- DOM操作有同步也有异步
	- async函数中，await语句执行后的代码，被当成异步任务
		- #+BEGIN_QUOTE
		  在 await 表达式之后的代码可以被认为是存在在链式调用的 then 回调中，多个 await 表达式都将加入链式调用的 then 回调中，返回值将作为最后一个 then 回调的返回值。
		  #+END_QUOTE
		- #+BEGIN_QUOTE
		  async 函数的函数体可以被看作是由 0 个或者多个 await 表达式分割开来的。从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。这样的话，一个不含 await 表达式的 async 函数是会同步运行的。然而，如果函数体内有一个 await 表达式，async 函数就一定会异步执行。
		  #+END_QUOTE
- ## react表单组件
- react并没有提供v-model组件
- 只要你绑定了事件，你会得到一个事件对象，这个对象event.target操作节点
- 当你点击按钮后来获取文本框的值，event对象得到按钮
- ### 二、受控组件
- 受控：表单的元素会被state状态给控制，导致state没有发生变化的时候，表单里面的内容是无法更新的
	- 我们需要定义state数据
	- 给input文本框绑定value值的时候，如果没有添加change事件，页面会报warning
	- value一旦写了值来自于state，当前这个组件称为受控组件
	- `<input readonly defaultValue={value} />`
- 想实现双向绑定就定义state，只显示就defaultValue
- ### 三、非受控组件
-
- [[伏忠奇说]]  #未来规划 #找工作 #伏忠奇说
	- 要么去行业龙头 要么去新兴企业嘛
	- 新能源现在的状态就是当年智能机转型时候的样子 混战 且有机会
	  哪怕后面洗牌掉队了 但是进入赛道了嘛
	- 行业龙头就比如 大疆 这种 市场占有率是绝对王者
	- 新兴现在就是车企嘛 蔚来 小鹏 吉利 之类的 新能源赛道 虽然现在进入车企已经算比较晚了 但是应该给的比较多
	- （其实去比亚迪都可以 虽然传统了一点 但是电池的红利还是可以吃很久了 就是给的比较低
- # React-生命周期函数
- 生命周期指的就是组件从创建到销毁的整个过程
- React生命周期分为一下三个阶段
  background-color:: #978626
	- 挂载阶段：组件创建以及初始化，页面渲染
	- 运行阶段(更新阶段)：这个阶段是最长的阶段，代表组件运行过程中数据变化
	- 销毁阶段：组件销毁的时候执行这个阶段函数
- 完整生命周期流程
	- https://s2.loli.net/2022/06/02/SBOy9PG3uzesfHc.jpg
- ## 二、挂载阶段
- componentWillMount：挂载之前，但是这个钩子函数在目前已废弃
- componentDidMount：只执行一次
- ### 作用
	- 获取DOM节点
	- 发送异步请求
	- 设置定时器、延时器
	- 绑定全局事件，比如document、window事件、路由事件
	- 这个生命周期中执行了定时器，全局事件绑定，销毁这个组件，要取消这些功能，不然会内存泄漏：组件已经销毁了，但是你的任务还在内存运行，闭包就是典型的内存泄漏
- ## 三、运行阶段
- 当检测到prop或者state的值发生变化时，执行页面的更新
- shouldComponentUpdate：必须返回Boolean，决定是否执行render()
	- 在更新之前执行的函数，可以控制是否更新，性能优化时才会用到这个
- 父组件引用子组件，更新props的值，执行顺序
  background-color:: #978626
	- 父组件的shouldComponentUpdate，返回true
	- 父组件的render函数，render函数里面加载子组件，跳转到子组件
	- 子组件的shouldComponentUpdate执行，返回true
	- 子组件render函数
	- 子组件的componentDidUpdate
	- 父组件的componentDidUpdate
- ## 四、销毁阶段
	- 组件移除当前这个模块
	- Vue中可以直接调用`this.$destroy`
	- React中销毁阶段要执行的函数 `componentWillUnmount()`
		- 资源清理，当你销毁组件的时候，删除掉这个组件创建全局事件，定时器等等、内存蝎落
		- 也可以报错当前这个页面中的数据
- ## 五、异常处理
- react16之后提供了一个`componentDidCatch`这个函数，可以处理组件中抛出的异常。不处理异常，异常会直接抛到页面。
- 一旦后代组件发生异常，就会执行该函数