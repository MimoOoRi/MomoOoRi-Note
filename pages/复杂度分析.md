- ### 事后统计法
  collapsed:: true
	- 缺点：
		- 受硬件条件影响
		- 受数据规模影响
- ## 时间复杂度
  collapsed:: true
	- 示例
	  collapsed:: true
		- ```js
		  int cal(int n) {
		     int sum = 0;
		     int i = 1;
		     for (; i <= n; ++i) {
		       sum = sum + i;
		     }
		     return sum;
		   }
		  ```
			- 第4、5行都运行了n遍
				- 括号内算作单独的块作用域
			- 时间复杂度：2+2n
	- 代码的执行时间`T(n)`与每行代码的执行次数`f(n)`成正比
		- #+BEGIN_EXPORT latex
		  T(n) = O(f(n))
		  #+END_EXPORT
		- ==O==：表示代码的执行时间与次数成正比
	- 时间复杂度 = 渐进时间复杂度 = ==算法的执行时间与数据规模之间的增长关系==
	- 公式中的==低阶、常量、系数== 不左右增长趋势
	- ### 计算规则：
		- 只关注循环执行次数最多的一段代码
		- 加法法则：总的时间复杂度 = 量级最大的那段代码的时间复杂度
		- 乘法法则：嵌套代码的复杂度 = 嵌套内外代码复杂度的乘积
	- ### 常见复杂度量级(按数量级递增)
		- 常量阶O(1)
		- 对数阶O(logn)
		- 线性阶O(n)
		- 线性对数阶O(nlogn)
		- 平方阶O(n^2)、立方阶O(n^3)、……、k次方阶O(n^k)
		- 指数阶O(2^n)
		- 阶乘阶O(n！)
	- `NP`：(非确定多项式)时间复杂度为 非多项式量级的算法问题
		- O(2^n)
		- O(n ！)
	- ### O(1)
		- 只要代码的执行时间不随n的增大而增长
		- ##### 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)
	- ### O(logn)、O(nlogn)
		- 在对数阶时间复杂度的表示方法里，我们忽略对数的底，同一表示为O(logn)
		- ##### O(nlogn)：归并排序、快速排序
	- O(m+n)、O(m*n)
		- 我们无法事先评估m和n谁的量级大，所以无法决定忽略谁。
- ## 空间复杂度
  collapsed:: true
	- ==渐进空间复杂度==：表示算法的储存空间与数据规模之间的增长关系
	- ![https://i.imgur.com/6msmJsf.png](https://i.imgur.com/6msmJsf.png){:height 287, :width 371}
- ## 最好情况时间复杂度
	- 在最理想的情况下，执行这段代码的时间复杂度
- ## 最坏情况时间复杂度
	- 在最糟糕的情况下，执行这段代码的时间复杂度
- ## 平均情况时间复杂度 = 加权平均时间复杂度 = 期望时间复杂度
	- 各种情况出现的==概率==*运行的次数 / 各种情况次数
- ## 均摊时间复杂度
	- ### 摊还分析
-