- [初中级，有答案](https://zhuanlan.zhihu.com/p/533130202?utm_source=wechat_session&utm_medium=social&utm_oi=977580216520966144)
	- vue的生命周期
	- vue的通讯方式 - listener、provider、inject
	- vue的双向绑定
	- webpack常用配置
	- http和https的区别
	- 盒模型 ： box = content+padding+border   ==没有margin！！==
	- http状态码
		- 301 永久重定向
		- 302  临时重定向
			- 比如未登陆的用户访问用户中心重定向到登陆页面。访问404页面会自动重定向到首页。
		- 304资源缓存，弱缓存
		- 403 禁止访问
		- 504  服务器繁忙
	- vuex
	- eventBus
	- 宏任务、微任务
		- 关键字：单线程，时间长，压入异步队列
- 输入一个URL到页面过程中发生了什么
	- 是否有==缓存==
	- 域名解析，发起请求
	- 建立连接(3次握手)
	- 获取资源(4次挥手)
	- 渲染页面(DOM树、CSS规则树、渲染树)
	- 布局
	- 绘制
- ### React优化
	- 不惜要的render：shouldComponentUpdate、PureComponent、React.memo
		- 当执行setState时，即使state数据没发生改变，也会去做virtual dom的diff
	- 避免在函数中使用箭头，因为每次render都会创建一个函数
	- <> </>  替换不必要的标记
	- [[Immutable]]  减少渲染次数，通过`is`完成对比
	- 懒加载组件、路由
		- 路由：import ()
		- 组件：suspense、lazy
		  background-color:: #793e3e
		- 源文件过大
- 前端维护项目
	- git拉取，运行。不能运行，解决node问题、依赖缺失、端口号不匹配
	- router文件夹看路由，找具体的组件
	- 其主要用了哪些插件，库，框架，最好不加入新的插件，库，框架，项目的依赖也最好不进行改动，容易导致其它报错，
	- 看看如何==调用api==的，如何管理组件间的状态的。
- [[ECharts使用笔记]]
- Vue组件如何封装？
	- 数据从父组件传入
	- 在父组件中处理事件
	- 使用slot
- AXXIS面试
	- pureComponent 和 Component的区别
	  background-color:: #978626
		- PureComponent其实就是一个继承自Component的子类，会自动加载shouldComponentUpdate函数。当组件需要更新的时候，shouldComponentUpdate会对组件的props和state进行一次浅比较。如果props和state都没有发生变化，那么render方法也就不会出发，当然也就省去了之后的虚拟dom的生成和对比，在react性能方面得到了优化。
		- PureComponent会==自动执行==shouldComponentUpdate函数，通过shallowEqual的浅对比，实现react的性能优化
		- 而Component必须要通过==自己去调用==生命周期函数shouldComponentUpdate来实现react组件的优化。
		- 若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较
		- 若是数组和对象等引用类型，则要引用不同，才会渲染
			- 所以useCallback缓存函数，引用地址没有变过，子组件不会更新
	- useMemo和useCallBack的使用场景
		- 两个都是用来缓存的，不同的是useMemo返回的是一个值，主要用于计算状态 useCallBack返回的是一个函数，主要用于 缓存函数,应用场景如: 需要缓存的函数,因为函数式组件每次任何一个 state 的变化 整个组件 都会 被重新刷新,一些函数是没有必要被重新刷新的,此时就应该缓存起来
	- 对象浅克隆有哪些方案，对象深克隆有哪些方案
		- 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址 - 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址 浅拷贝： Object.assign Array.prototype.slice() Array.prototype.concat() 拓展运算符 深拷贝： - _.cloneDeep() - jQuery.extend() - JSON.stringify() - 手写循环递归
	- call、bind、apply动态this指向
		- call():改变this指向的同时，会立即执行对应的函数，如果需要传递参数，从call（）的第二个参数开始依次传递 apply（）：改变this指向的同时，会立即执行对应的函数，如果需要传递参数，在apply（）的第二个参数中传递一个数组，数组中存放所有需要的参数 bind（）：改变this指向的同时，返回一个新的函数（需要重新调用），如果需要传递参数，在调用新函数时直接传递即可
	- 说说你对闭包的理解？闭包使用场景
		- 闭包：想要使用在其他地方使用一个局部变量。避免变量污染，使用局部变量。只有在当前环境下才能获取到一个变量值，想要在另外一个函数内使用，
		-
		- 闭包让你可以在一个内层函数中访问到其外层函数的作用域 - 创建私有变量 - 延长变量的生命周期
		-
		- 作用：
			- 函数作为参数被传递
			- 函数作为返回值被返回
			- ==隐藏数据==：
		- 优点：
			- ①全局变量可以重复使用，但是容易造成变量污染。不同的地方定义了相同的全局变量,这样就会产生混乱。
			- ②局部变量仅在局部作用域内有效，不可以重复使用，不会造成变量污染。
			- ③闭包结合了全局变量和局部变量的优点。==可以重复使用变量，并且不会造成变量污染。==
		- 缺点：
			- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。==解决方法是，在退出函数之前，将不使用的局部变量全部删除==。
	- React.memo  浅比较
		- 使用 React 内部对象的 is 函数将两个函数参数进行比较
		  [浅比较原理](https://blog.csdn.net/web220507/article/details/125215357)
	- ECharts 图例
		- legend 写图例的位置信息，横向还是竖向
	- decorator装饰器
		- [react中的高阶组件](https://blog.csdn.net/cuandeqin2083/article/details/100864396)
	- push、pull  (订阅开发模式)
		- [消息队列pull和push](https://wenku.baidu.com/view/f36c954f021ca300a6c30c22590102020740f2d7.html)
	- 分支冲突
	- promise中的All和race的用法
		- Promise.all()可以将多个实例组装个成一个新实例，全都成功的时候返回一个成功的数组；失败的时候则返回最先被reject失败状态的值。 适用场景：比如当一个页面需要在很多个模块的数据都返回回来时才正常显示，否则loading。 promise.all中的子任务是并发执行的，适用于前后没有依赖关系的。 Promise.race()意为赛跑的意思，也就是数组中的任务哪个获取的块，就返回哪个，不管结果本身是成功还是失败。一般用于和定时器绑定，比如将一个请求和三秒的定时器包装成Promise实例，加入到Promise队列中，请求三秒中还没有回应时，给用户一些提示或相应的操作。
	- 定时器的执行顺序或机制？
		- 因为js是单线程的，浏览器遇到setTimeout或者setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才执行定时器的代码。**所以即使把定时器的时间设置为0还是会先执行当前的一些代码
	- Doctype作用? 严格模式与==混杂模式==如何区分？它们有何意义
		- 参考答案Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。
		- 严格模式：
			- ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"`use strict`";。
			- 作用
				- 消除代码运行的一些不安全之处，保证代码运行的安全
				- 提高编译器效率，增加运行速度；
				- 为未来新版本的Javascript做好铺垫。
			- 区别
				- 严格模式必须 先声明，再赋值
				- 全局里的函数，this指向undefined，而不是window
				- 变量和函数的重名，会报错  ReferenceError
				-
	- Cookie如何防范XSS攻击
		- XSS（跨站脚本攻击）是指攻击者在返回的HTML中==嵌入javascript脚本==，为了减轻这些攻击，需要在HTTP头部配上，
			- set-cookie：
				- `httponly`-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。
				- `secure` - 这个属性告诉浏览器仅在请求为https的时候发送cookie。
	- 你了解的浏览器的重绘和回流导致的性能问题
		- 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。 重绘是当节点需要更改外观而不会影响布局的，比如`改变 color`就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 `定位或者浮动` 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关
	- React.memo第二个参数有什么作用
		- 默认情况下其只会对 props 做浅层对比，遇到层级比较深的复杂对象时，就力不从心了。对于特定的业务场景，可能需要类似 shouldComponentUpdate 这样的 API，这时通过 memo 的第二个参数来实现
			- 第二个参：回调(prevProps, nextProps)
				- 返回值与shouldComponent相反，==返回false，触发render==
	- useEffect里面可以调用异步函数async&await吗
		- useEffect的回调不能是个异步，但是里面可以写一个立即执行函数
		- 创建一个fetchData，在useEffect中调用
			- ```js
			  const fetchMyAPI =async()=> {
			    let response = await fetch('api/data')
			    response = await res.json()
			    dataSet(response)
			  }
			   
			  useEffect(() => {
			    fetchMyAPI();
			  }, []);
			  ```
		- 方法二：useEffect中异步函数采用IIFE写法（ 即立即调用的函数式表达式）
			- ```js
			  const MyFunctionnalComponent: React.FC = props => {
			    useEffect(() => {
			      // Using an IIFE
			      (async function anyNameFunction() {
			        await loadContent();
			      })();
			    }, []);
			    return <div></div>;
			  };
			  ```
	- 原生js的立即执行函数有了解过吗？
		- 方式一：最前最后加括号，`(function(){alert(1);}())`;
		- 方式二：function前面加运算符，常见的是!与void， !function(){alert(1);}(); void function(){alert(2);}(); 好处：通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。此时若是想访问全局对象，将全局对象以参数形式传进去即可。
	- ref和forwardRef的区别
		- ref是React提供的用来操纵React组件==实例==或者DOM元素的接口。
		- 在React的类组件中，我们通过createRef创建ref。在函数式组件中通过useRef创建ref。 但是==ref不能挂到一个函数式组，除非使用forwardRef==。
	- promise怎样获取失败的结果？
		- catch，reject
	- useEffect第二个参数可以是函数吗
		- 可以
	- 如果useEffect第二个参数可以是函数会造成什么问题呢
		- 第二个参数是一个数组
		- 在JavaScript中， `{} === {}` 结果是false， `{a:1} === {a:1}` 同样，由此造成了react以为两个值不同，就一直的渲染最终页面死循环。
	- 在项目中，遇到的最大的bug是什么，怎么解决的呢
		- 我在项目中没有遇到过太大的bug，小的bug的话就现在报错的前面打印输出一下，一般都能找出问题，如果不能的话，在百度，实在是没办法，就找项目的负责人比我厉害的来看看，就比如之前....（随便举了一个例子）
	- 继承是怎么实现的(通过原型)
	- js中的继承是语法还是语法糖     语法糖
	- 原型、原型链
	- 了解事件循环吗
		- 了解，就是程序执行的时候，先执行同步代码，再执行异步代码，当遇到异步时，丢到任务队列里面，等同步执行完了再去任务队列里面拿异步的，遵循先进先出，这个重复从队列里面拿东西出来执行的过程就是事件循环
	- 对虚拟dom有什么了解
	- 虚拟dom是怎么实现的
		- 这个就是通过js当中的Object对象去模拟的节点
	- 虚拟dom有什么缺点
		- 这个就是刚刚说的它是用js对象去模拟的节点，就比较占内存
	- sessionStorage 可以定时吗
	- 在登录的时候，登录的用户角色权限是如何处理的，怎么高速后端你是登录用户还是管理员？
		- 通过token来进行判断，后端会根据用户登录的信息与数据库进行匹配，然后返回相对应的权限信息。
	- 深克隆用递归具体怎么实现的？
		- 首先对需要克隆的对象进行遍历，判断里面属性值的类型 2、属性值的类型分为两种：原始值(string,number,null,undefine,boolean)和引用值（object,array） 3、如果遍历到的属性值为原始值，则直接进行拷贝 4、如果遍历到的属性值为引用值类型，则需要在目标对象的对应属性地方建立新的引用值类型，以原始引用值类型为模板，新建立的引用值为目标重复1，2，3步骤进行拷贝，从而实现深层拷贝。
	- 哪些数据用本地存储，哪些存储用Redux存储？有啥区别?
		- redux 在页面刷新后值会被初始化，无法实现数据持久化。但是 redux 的数据可以影响子路由页面响应式变化。 localStorage 保存的数据不会被刷新等操作影响，可以持久化。但是localStorage 不具备 redux 的响应式变化功能。
	- js对象的遍历方式有哪些
		- Object.keys 、values、in、of、Object.entries
	- 服务器渲染 ssr
	- 登录流程的详细实现？
		- 前端登录流程 初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token，和一个用户信息的值，前端拿到token，将token储存到Vuex中，然后从Vuex中把token的值存入浏览器Cookies中。把用户信息存到Vuex然后再存储到LocalStroage中 然后跳转到下一个页面，根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面师判断Cookies中是否有token，没有就跳转到登录页，有就跳转到相应的页面，我们应该再每次发送post/get请求的时候应该加入token，常用方法再项目utils/service.js中添加全局拦截器，将token的值放入请求头中； 后端判断请求头中有无token，有token，就拿到token并验证token是否过期，在这里过期会返回无效的token然后有个跳回登录页面重新登录并且清楚本地用户的信息；
	- typeof null输出的是什么
		- 对象
	- instanceof是什么及使用方法
		- instanceof 是用来判断左侧对象是否是右侧构造函数的实例化对象，object instanceof 构造函数， 它有两个必传参数，左侧必须为对象类型，右侧必须为函数类型。返回值为 Boolean 类型。
	- useMemo和useCallback
		- 都是计算属性，useMemo返回结算后的结果,一般都是字符串\对象 useCallBack也是可以执行计算属性,返回的是一个函数.
	- charCodeAt()返回的是什么
		- ASCII码
	- 说说闭包
		- 闭包的原理+应用范围
	- cookie
		- cookie是有时间限制
	- echarts常用属性
		- 我们项目这块比较简单，所以我都是直接copy的案例
	- react是怎么检测错误组件
	- use effect是父元素还是子元素先触发
		- 是子组件先触发，子组件在挂载好了之后，父组件才完成挂在阶段
	- react怎么实现捕获的阶段
	- pureComponent和component的区别
	- 对象浅克隆有哪些方案，对象深克隆有哪些方案
		- 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址 - 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址 浅拷贝： Object.assign Array.prototype.slice() Array.prototype.concat() 拓展运算符 深拷贝： - _.cloneDeep() - jQuery.extend() - JSON.stringify() - 手写循环递归
	- 项目难点
	  background-color:: #978626
	- vue的双向数据绑定是如何实现的
		- 先回答了数据劫持，然后用input举例，利用input事件和set方法来进行设置。
	- diff算法的理解
	- 当在网址上输入URL后，页面生成之间会发生什么？
	- 事件循环是什么？
	- 对typejs的了解？
		- 类型接口和泛型
	- uniapp有哪些缺陷
		- 编译问题和一些api的兼容性问题
	- 底层，多看js，递归、闭包、
	- grid 边距  grid-column-gap
	-
	- 封装登录授权组件，需要获取用户信息。
	- 微信登录，和后台先填写用户信息，手机号预置，用户登录，填写信息，更新信息。
		- 公司注册，填写后台注册人员信息。新用户手机号注册，
		-
	-
	- 今晚试题
	- 常用Hook有哪些？
		- useState：响应式数据
		- useEffect：监听、模拟生命周期
		- useMemo：计算属性，缓存数据
		- useCallBack：计算属性，缓存函数
		- useHistory：获取history对象，可以进行页面跳转
		- useLocation：获取location对象，可以获取当前页面参数，例如path
	- 表格嵌套如何实现？
	- React的副作用是什么？
		- 就是useEffect
	- 生命周期useEffect怎么用
		- return 函数：模拟销毁阶段
		- 第二个参数为[]，模拟挂载后生命周期
	- 免责声明
		- 跳转页面，显示免责声明
		- 触发弹窗，显示免责声明
		- 都有倒计时，计时结束才能够点击关闭按钮
	- 浅克隆和深克隆
		- 浅克隆：拷贝基本数据类型，拷贝引用类型地址
		- 深克隆：引用类型不会影响原本数据
	- 异步请求的方法
		- Promise、setTimeout、setInterval、genarator、async/await
	- 页面如何做SEO优化
		- SSR(服务端渲染)
		- 进行一个meta关键字keywords添加内容
		- 使用语义化标签
	- 后端数据结构是怎样的，表单联动怎么做的
		- 树形、扁平化
		- 树形：通过获取第一个下拉框的数据，通过计算属性返回第二个下拉框的内容
	- 单页开发的优势
		- 内容更新不需要重新夹在整个页面
	- 小程序如何分包
		- 建立subpackage文件夹(不必要)
		- 在pages.json中subpackage字段配置root、pages
	- 小程序如何传参
		- uniapp使用uni.NavigatorTo，路径拼接，params获取传参
		- uniapp 本地存储
	- 订阅和发布者模式
		- 数据发生变化，通知订阅者进行更新
		- 实际问的是pull和push的优缺点
			- [消息队列pull和push](https://wenku.baidu.com/view/f36c954f021ca300a6c30c22590102020740f2d7.html)
	- React.memo浅比较
		- 使用 React 内部对象的 is 函数将两个函数参数进行比较
		  [浅比较原理](https://blog.csdn.net/web220507/article/details/125215357)
	- ### watch、computed、methods三者区别
		- watch：是监听某一个值的变化，初始化时不会监听；如果要在数据变化的同时进行异步操作或者是比较大的开销时，推荐watch
		- computed：有缓存，如果计算的值没有发生改变，是会走缓存的；而且一定要return。
	- 撤销git，回退版本  `git reset --hard`
	- vue2 props是异步更新，需要使用 $nextTick
	-
	- AXXIS：项目、技术栈、担任角色
		- 权限设置：超管，创建项目、role，路由、
		- 按钮权限(创建项目)、按钮列表
		- add
		- 角色按钮
		- 登录分成几步：
			- 后台监理
			- 手机号注册
			- 返回token，
			- uniapp登录
				- uni.login  code  后台，openid，
				- 不要说堆栈
				- a.x = 5,   a...x=b
				- b.x = 7
			- 递归，深拷贝
				- 类型，判断  constructor、instanceof
		- shouldComponent
		- 报错  componentDidCatch
		- align-
		- 写hook，key